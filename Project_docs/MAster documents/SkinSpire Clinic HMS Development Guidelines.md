# Skinspire Clinic HMS Development Guidelines

## Overview

This document consolidates technical guidelines for development on the Skinspire Clinic Hospital Management System. It provides a clear reference for maintaining consistency across all features and modules while adhering to the established architectural patterns.

## Project Directory Structure
skinspire_v2/
├── app/                            # Application package
│   ├── api/                        # API endpoints
│   │   ├── routes/                 # API route handlers
│   │   │   ├── admin.py            # Admin API routes
│   │   │   ├── auth.py             # Authentication API routes
│   │   │   ├── patient.py          # Patient API routes
│   │   │   └── [feature].py        # Feature-specific API routes
│   ├── config/                     # Configuration
│   │   ├── db_config.py            # Database configuration
│   │   └── settings.py             # Application settings
│   ├── core/                       # Core functionality
│   │   ├── environment.py          # Environment management
│   │   └── db_operations/          # Database operations
│   ├── database/                   # Database definitions
│   │   ├── triggers/               # SQL triggers
│   │   └── migrations/             # Custom migrations
│   ├── forms/                      # Form definitions
│   │   ├── auth_forms.py           # Authentication forms
│   │   └── [feature]_forms.py      # Feature-specific forms
│   ├── models/                     # SQLAlchemy models
│   │   ├── base.py                 # Base models and mixins
│   │   ├── config.py               # Configuration models
│   │   ├── master.py               # Master data models
│   │   └── transaction.py          # Transaction models
│   ├── security/                   # Security components
│   │   ├── authentication/         # Authentication logic
│   │   ├── authorization/          # Authorization logic
│   │   ├── encryption/             # Encryption utilities
│   │   └── routes/                 # Security-related routes
│   ├── services/                   # Service layer
│   │   ├── database_service.py     # Database service
│   │   └── [feature]_service.py    # Feature-specific services
│   ├── static/                     # Static assets
│   │   ├── css/                    # CSS files
│   │   ├── js/                     # JavaScript files
│   │   └── images/                 # Image assets
│   ├── templates/                  # Jinja2 templates
│   │   ├── auth/                   # Authentication templates
│   │   ├── components/             # Reusable components
│   │   ├── layouts/                # Layout templates
│   │   └── [feature]/              # Feature-specific templates
│   ├── utils/                      # Utility functions
│   └── views/                      # Web view handlers
│       ├── auth_views.py           # Authentication views
│       └── [feature]views.py      # Feature-specific views
├── migrations/                     # Alembic migrations
│   └── versions/                   # Migration versions
├── scripts/                        # Maintenance scripts
│   └── manage_db.py                # Database management CLI
├── tests/                          # Test suite
│   ├── conftest.py                 # Test fixtures
│   ├── test_api/                   # API tests
│   ├── test_frontend/              # Frontend tests
│   └── test[feature]/             # Feature-specific tests
└── Project_docs/                   # Documentation
Copy
## File Location Guidelines

When implementing new features, add files to the appropriate directories:

### Core Architecture

1. **Models**
   - **Location**: `app/models/`
   - **Add to**:
     - `base.py` for base classes and mixins
     - `config.py` for configuration models
     - `master.py` for master data
     - `transaction.py` for operational data
   - **Modify existing files** instead of creating new ones

2. **Database Migrations**
   - **Location**: `migrations/versions/`
   - **Generated by**: `flask db migrate -m "Description"`
   - **Not created manually**

3. **SQL Triggers/Functions**
   - **Location**: `app/database/triggers/`
   - **Files**: 
     - `functions.sql` for database functions
     - Feature-specific SQL files if needed

### Web Interface Components

4. **Forms**
   - **Location**: `app/forms/`
   - **Create**: `[feature]_forms.py` for feature-specific forms
   - **Example**: `appointment_forms.py` for appointment features

5. **Web Views**
   - **Location**: `app/views/`
   - **Create**: `[feature]_views.py` for feature-specific views
   - **Example**: `appointment_views.py` for appointment views

6. **Templates**
   - **Location**: `app/templates/`
   - **Create**: `[feature]/` directory for feature templates
   - **Files**:
     - `list.html` for list views
     - `detail.html` for detail views
     - `form.html` or `edit.html` for forms
   - **Example**: `appointments/create.html`

7. **Static Assets**
   - **Location**: `app/static/`
   - **Subdirectories**:
     - `css/` for stylesheets
     - `js/pages/[feature].js` for feature-specific JavaScript
     - `images/` for images

### API Components

8. **API Routes**
   - **Location**: `app/api/routes/`
   - **Create**: `[feature].py` for feature-specific API routes
   - **Example**: `appointments.py` for appointment API endpoints

9. **Services**
   - **Location**: `app/services/`
   - **Create**: `[feature]_service.py` for business logic
   - **Example**: `appointment_service.py` for appointment services

### Security Components

10. **Authentication**
    - **Location**: `app/security/authentication/`
    - **Modify**: `auth_manager.py` for authentication logic changes
    - **Create**: New files only for major authentication subsystems

11. **Authorization**
    - **Location**: `app/security/authorization/`
    - **Modify**: `permission_validator.py` for permission checks
    - **Create**: New files only for specialized authorization needs

12. **Encryption**
    - **Location**: `app/security/encryption/`
    - **Use**: `field_encryption.py` for field-level encryption

### Testing

13. **Tests**
    - **Location**: `tests/`
    - **Create**:
      - `test_api/test_[feature]_api.py` for API tests
      - `test_frontend/test_[feature]_ui.py` for UI tests
      - `test_[feature]/test_[component].py` for component tests

### Documentation

14. **Documentation**
    - **Location**: `Project_docs/`
    - **Create**: `[feature]/` directory for feature documentation
    - **Files**:
      - `overview.md` for feature overview
      - `implementation.md` for implementation details
      - `usage.md` for usage guidelines

## Common Enhancement Patterns

### 1. Adding a New Entity

Files to create/modify:

1. **Add model**: `app/models/transaction.py` or `app/models/master.py`
2. **Run migration**: `flask db migrate -m "Add new entity"`
3. **Create forms**: `app/forms/entity_forms.py`
4. **Create service**: `app/services/entity_service.py`
5. **Create API routes**: `app/api/routes/entity.py`
6. **Create web views**: `app/views/entity_views.py`
7. **Create templates**: `app/templates/entity/`
8. **Create tests**: `tests/test_entity/`

### 2. Enhancing Existing Features

Files to modify:

1. **Update models**: Add fields to existing models
2. **Run migration**: `flask db migrate -m "Update entity with new fields"`
3. **Update forms**: Add fields to existing forms
4. **Update services**: Add methods to existing services
5. **Update views**: Enhance existing view functions
6. **Update templates**: Modify existing templates

### 3. Adding Security Features

Files to modify:

1. **Authentication**: `app/security/authentication/auth_manager.py`
2. **Authorization**: `app/security/authorization/permission_validator.py`
3. **User model**: `app/models/transaction.py` (User class)
4. **Security services**: `app/services/` (Create new security-related services)
5. **Security views**: `app/security/routes/` (Add security-related routes)

### 4. Adding Reports or Analytics

Files to create/modify:

1. **Create service**: `app/services/report_service.py`
2. **Create views**: `app/views/report_views.py`
3. **Create templates**: `app/templates/reports/`
4. **Create API routes**: `app/api/routes/reports.py` (if applicable)

## Reference Files for Common Features

When implementing new features, reference these existing files for patterns:

### Authentication and User Management

- **Models**: `app/models/transaction.py` (User model)
- **Forms**: `app/forms/auth_forms.py`
- **Views**: `app/views/auth_views.py`
- **Templates**: `app/templates/auth/`
- **Services**: `app/services/profile_service.py`, `app/services/user_service.py`

### Master Data Management

- **Models**: `app/models/master.py`
- **Forms**: Reference admin form patterns
- **Views**: `app/views/admin_views.py`
- **Templates**: `app/templates/admin/`

### Transaction Processing

- **Database Access**: `app/services/database_service.py`
- **Session Management**: `app/security/authentication/session_manager.py`
- **Transaction Models**: `app/models/transaction.py`

### API Development

- **Authentication**: `app/security/routes/auth.py`
- **API Routes**: `app/api/routes/`
- **Decorators**: `app/security/authorization/decorators.py`

## Core Architecture Principles

1. **Layered Architecture**
   - UI Layer (Templates, Forms)
   - Web Layer (Views, API Routes)
   - Service Layer (Business Logic)
   - Data Access Layer (Database Services)
   - Model Layer (SQLAlchemy Models)

2. **Separation of Concerns**
   - Each component should have a single responsibility
   - Business logic belongs in services, not views
   - Database access is centralized through database_service.py
   - Views handle request processing and template rendering

3. **Progressive Enhancement**
   - New features must maintain backward compatibility
   - Incremental improvements over wholesale replacements
   - Clear migration paths from old to new patterns

## Database Guidelines

### 1. Model Organization

- **Base Models**: Core classes and mixins in `app/models/base.py`
- **Configuration Models**: System settings in `app/models/config.py`
- **Master Data Models**: Reference data in `app/models/master.py`
- **Transaction Models**: Operational data in `app/models/transaction.py`

### 2. Database Access Patterns

Always use the centralized database service:

```python
from app.services.database_service import get_db_session

def my_function():
    with get_db_session() as session:
        # Database operations
        user = session.query(User).filter_by(user_id=user_id).first()
        # More operations...
For service functions that may be called with an existing session:
pythonCopydef service_function(data, session=None):
    if session is not None:
        return _perform_operation(session, data)
    
    with get_db_session() as new_session:
        return _perform_operation(new_session, data)
        
def _perform_operation(session, data):
    # Implementation with the provided session
3. Transaction Management

Use session.flush() to make changes visible within a transaction
Never call session.commit() or session.rollback() directly
Let the context manager handle transaction boundaries
Use nested transactions for complex operations when appropriate

4. Entity Lifecycle Management
For entities that need to exist outside a session:
pythonCopyfrom app.services.database_service import get_detached_copy, get_entity_dict

# Get a safe detached copy
with get_db_session() as session:
    user = session.query(User).filter_by(id=user_id).first()
    detached_user = get_detached_copy(user)

# Or convert to a dictionary
with get_db_session() as session:
    user = session.query(User).filter_by(id=user_id).first()
    user_dict = get_entity_dict(user)
5. Database Migrations
For new models or schema changes:

Define your models in the appropriate module
Generate migrations: flask db migrate -m "Description"
Review the migration file for correctness
Apply migrations: flask db upgrade
Test with the new schema

Authentication & Authorization
1. Authentication Patterns
For web views (using Flask-Login):
pythonCopy@app_bp.route('/route')
@login_required
def protected_route():
    # Implementation using current_user from Flask-Login
For API routes (using token authentication):
pythonCopy@api_bp.route('/route')
@token_required
def protected_api(current_user, session):
    # Implementation using provided user and session
2. Permission Checks
For authorization in API routes:
pythonCopy@api_bp.route('/admin/resource')
@token_required
@require_permission('resource_module', 'edit')
def admin_resource(current_user, session):
    # Implementation with required permissions
For authorization in web views:
pythonCopy@app_bp.route('/admin/page')
@login_required
def admin_page():
    from app.security.authorization.permission_validator import has_permission
    
    if not has_permission(current_user, 'admin_module', 'view'):
        flash('You do not have permission to access this page', 'error')
        return redirect(url_for('dashboard'))
        
    # Implementation for authorized users
View Layer Guidelines
1. Blueprint Structure
Organize routes by functional area:
pythonCopy# app/views/module_views.py
module_bp = Blueprint('module', __name__)

@module_bp.route('/')
def index():
    # Implementation

@module_bp.route('/detail/<id>')
def detail(id):
    # Implementation
2. Form Handling
Use WTForms for all form processing:
pythonCopyform = ModuleForm()

if form.validate_on_submit():
    try:
        # Process form data
        flash('Operation successful', 'success')
        return redirect(url_for('module.index'))
    except Exception as e:
        flash(f'Error: {str(e)}', 'error')
        app.logger.error(f"Form error: {str(e)}", exc_info=True)

return render_template('module/form.html', form=form)
3. Error Handling
Implement consistent error handling:
pythonCopytry:
    # Operation that might fail
except Exception as e:
    flash(f'Operation failed: {str(e)}', 'error')
    current_app.logger.error(f"Error in module: {str(e)}", exc_info=True)
    return redirect(url_for('module.index'))
Service Layer Guidelines
1. Service Structure
Create services for business logic:
pythonCopy# app/services/module_service.py
class ModuleService:
    @classmethod
    def perform_operation(cls, data, session=None):
        if session is not None:
            return cls._perform_operation(session, data)
        
        with get_db_session() as new_session:
            return cls._perform_operation(new_session, data)
    
    @classmethod
    def _perform_operation(cls, session, data):
        # Implementation
2. Error Handling in Services
Return structured results with success/error information:
pythonCopy@classmethod
def operation(cls, params):
    try:
        # Implementation
        return {"success": True, "data": result}
    except Exception as e:
        logger.error(f"Operation error: {str(e)}", exc_info=True)
        return {"success": False, "message": str(e)}
Template Guidelines
1. Template Structure
Extend base layouts:
htmlCopy{% extends "layouts/dashboard.html" %}

{% block title %}Page Title{% endblock %}

{% block content %}
    <!-- Page content -->
{% endblock %}
2. Form Rendering
Consistent form rendering:
htmlCopy<form method="POST" action="{{ url_for('module.action') }}">
    {{ form.hidden_tag() }}
    
    <div class="form-group">
        {{ form.field.label(class="block text-sm font-medium text-gray-700") }}
        {{ form.field(class="mt-1 block w-full py-2 px-3 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm") }}
        {% if form.field.errors %}
            {% for error in form.field.errors %}
                <p class="text-red-500 text-xs italic">{{ error }}</p>
            {% endfor %}
        {% endif %}
    </div>
    
    <button type="submit" class="inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
        Submit
    </button>
</form>
3. Flash Messages
Display flash messages consistently:
htmlCopy{% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
        {% for category, message in messages %}
            <div class="rounded-md p-4 {{ 'bg-red-50 text-red-700' if category == 'error' else 'bg-green-50 text-green-700' }}">
                <div class="flex">
                    <div class="flex-shrink-0">
                        {% if category == 'error' %}
                        <svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                        </svg>
                        {% else %}
                        <svg class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                        </svg>
                        {% endif %}
                    </div>
                    <div class="ml-3">
                        <p class="text-sm font-medium">{{ message }}</p>
                    </div>
                </div>
            </div>
        {% endfor %}
    {% endif %}
{% endwith %}
Testing Guidelines
1. Test Structure
Organize tests by component:
pythonCopy# tests/test_module/test_component.py
def test_functionality():
    # Setup
    # Exercise
    # Verify
    # Cleanup
2. Database Testing
Use the database service for test setup and verification:
pythonCopydef test_database_operation():
    with get_db_session() as session:
        # Setup test data
        entity = Entity(name="Test")
        session.add(entity)
        session.flush()
        
        # Exercise
        result = function_under_test(entity.id)
        
        # Verify
        assert result.name == "Test"
Integration Patterns
1. API to Service Integration
Pass service results through API endpoints:
pythonCopy@api_bp.route('/resource', methods=['POST'])
@token_required
def create_resource(current_user, session):
    data = request.get_json()
    
    result = ResourceService.create_resource(data, session=session)
    
    if result['success']:
        return jsonify(result), 201
    else:
        return jsonify({'error': result['message']}), 400
2. View to Service Integration
Use services from view functions:
pythonCopy@app_bp.route('/resource/create', methods=['GET', 'POST'])
@login_required
def create_resource():
    form = ResourceForm()
    
    if form.validate_on_submit():
        data = {
            'name': form.name.data,
            'description': form.description.data
        }
        
        result = ResourceService.create_resource(data)
        
        if result['success']:
            flash('Resource created successfully', 'success')
            return redirect(url_for('app.resource_list'))
        else:
            flash(f'Error: {result["message"]}', 'error')
    
    return render_template('resource/create.html', form=form)
Feature Implementation Process
When implementing new features, follow this workflow:

Define Models

Add models to appropriate files in app/models/
Generate and apply database migrations


Create Forms

Define form classes in app/forms/[feature]_forms.py


Implement Services

Build service classes in app/services/[feature]_service.py
Ensure proper session management
Implement comprehensive error handling


Build API Endpoints (if needed)

Create API routes in app/api/routes/[feature].py
Connect API endpoints to services
Implement input validation and error responses


Create Web Views

Implement view functions in app/views/[feature]_views.py
Connect views to services or API as appropriate
Handle form submission and errors


Design Templates

Create HTML templates in app/templates/[feature]/
Ensure consistent styling and components
Implement proper form rendering and validation display


Write Tests

Create tests in tests/test_[feature]/
Implement API tests in tests/test_api/
Write UI tests in tests/test_frontend/


Document

Update documentation in Project_docs/[feature]/
Document API endpoints and parameters
Update developer guidelines as needed



Conclusion
Following these guidelines consistently will ensure that the Skinspire Clinic Hospital Management System maintains a coherent architecture, predictable behavior, and high maintainability across all features and modules. All developers should adhere to these patterns and communicate any necessary deviations or enhancements to the team.